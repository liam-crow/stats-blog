---
title: A new way of interpreting Brownlow Medal data
author: Liam Crowhurst
date: '2020-07-16'
slug: afl-brownlow-medal-votes-data-analysis-R
categories:
  - AFL Analysis
tags:
  - R
  - Useful AFL Stats
banner: ''
description: 'An in-depth look as to why the Brownlow is hard to predict, using advanced statistics techniques, including umap and pca.'
images: []
menu: ''
---

# Introduction

The Brownlow medal, one of the most prestigious AFL awards, is notoriously difficult to predict. You can read this article from [Fat Stats](https://www.thefatstats.com/post/predicting-the-brownlow-is-hard){target="blank"} for a great look as to why. Here's a quick summary:

- Umpires are human and have their own biases
- Highly predictive stats from last year may not be predictive this year
- Media influence may impact umpires when they vote

Another point that I'd like to throw into the mix:

> Only 3 out of 44 players can actually receive a vote!

6% of players per game receive a vote! Further more, 1 out of 44 receive the 3 votes. This is a ridiculously small sample size, and predicting rare events is one of the trickiest things to do in predictive modelling. I'm gonna try anyway.

# The plan

In this post I'll be exploring the underlying structure of the data that players accumulate per game. To do do this I'll be employing 2 different techniques that employ dimensionality reduction. Dimensionality reduction is a way of representing high dimensional datasets in 2 or 3 dimensions that retain as much information about the original dataset as possible.

Once a low dimensional representation has been calculated and visualised, we expect to see different structures between 0 vote games and vote worthy games. Here are the two methods I'll be using.

- Principal Component Analysis (PCA, linear, fairly common, robust)
- Uniform Manifold Approximation and Projection (UMAP, non-linear, relatively new, tricky)

PCA reduces the dimensions of the dataset while preserving as much of the total variability as possible. PCA outputs a linear combination of vectors, where each principal component explains a proportion of variability in the dataset. [1](https://royalsocietypublishing.org/doi/10.1098/rsta.2015.0202){target="blank"}

UMAP is a non-linear dimension reduction technique and uses a fuzzy topological structure to model the manifold. The end result is a low dimensional projection of the data that is closest to its equivalent fuzzy topological structure. [2](https://umap-learn.readthedocs.io/en/latest/){target="blank"}

Using each method, we can compare the visualisations and make judgments about which method better represents the structure of the data, and helps us differentiate between vote worthy games.

### What do I mean by dimensionality reduction?

Each statistic that you can record in the AFL is a dimension (ie kicks, marks and handballs). Lets plot these on a 3D chart and colour each point by the bronwlow votes they received.

```{r setup, warning=F, message=F, echo=F}
library(dplyr)
afltables <- fitzRoy::get_afltables_stats(start_date = '2018-01-01', end_date = '2020-01-01')
names(afltables) <- snakecase::to_snake_case(names(afltables))

afltables <- afltables %>% 
  mutate(brownlow_votes = as.character(brownlow_votes)) %>% 
  filter(round %in% c(1:23))

afltables_18 <- afltables %>% filter(season == 2018)
```

```{r warning=F, message=F, echo=F}
aflt_2019_r1 <- afltables %>% 
  filter(season == 2019, round == '1')

plotly::plot_ly(aflt_2019_r1, x = ~kicks, y = ~marks, z = ~handballs, color = ~brownlow_votes, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', kicks, '<br>Marks:', marks, '<br>Hb:', handballs, '<br>Goals:', goals)) %>% 
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'Kicks'),
                     yaxis = list(title = 'Marks'),
                     zaxis = list(title = 'Handballs')))
```

This is a 3 dimensional graph where each point is a player from round 1 2019, corresponding to their stats for that game. Humans can only realistically understand 3 spatial dimension, but computers and algorithms have the luxury of analysing 100's of dimensions, a fact that we can exploit. You can hover over points and see who the player is and their corresponding stats.

In reality, the AFL records hundreds of data points including free kicks, frees against, bounces and contested posessions, just to name a few. We can't visualise all these at once, so we need a representation of this data in a form we can understand. Dimensionality reduction is the process of taking these 100's of dimensions and leaving us with 2 (or 3) that most accurately correspond to its higher dimensional shape.

# The first attempts

### Principal component analysis (no scaling)

For the next sections I'll be using the 2018 Home and Away Season, and sourcing the data from [fitzRoy](https://github.com/jimmyday12/fitzRoy){target="blank"}. I'll be using `prcomp` from `stats` to generate the principal components.

```{r, warning=F, message=F, echo=F}
afltables_18_ind <- afltables_18 %>% 
  select(id, first_name, surname, brownlow_votes)

afltables_18_data <- afltables_18 %>% 
  select(kicks, marks, handballs, goals, behinds, hit_outs, tackles, rebounds, inside_50_s, clearances, clangers, frees_for, frees_against, contested_possessions, uncontested_possessions, contested_marks, marks_inside_50, one_percenters, bounces, goal_assists, time_on_ground)

pca_2018 <- prcomp(afltables_18_data, scale = F, center = T)

pca_raw <- as_tibble(pca_2018$x)

pca_comb <- cbind(afltables_18_ind, afltables_18_data, pca_raw)

plotly::plot_ly(pca_comb, x = ~PC1, y = ~PC2, color = ~brownlow_votes, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', kicks, '<br>Marks:', marks,
                      '<br>Hb:', handballs, '<br>Goals:', goals,
                      '<br>HO:', hit_outs, '<br>OP', one_percenters)) %>% 
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2')))
```

A nice feature of `plotly` is that you can click the colours on the legend to isolate certain groups.

Here we can see PC1 and PC2, the top 2 principal components. Each dot is represents a player in a game, with the coordinates representing its approximation in lower dimensional space. I've added colours corresponding to the votes afterwards. 

What we would like to see is an nice distinction between the groups, which isn't too evident. Most of the 1, 2 and 3 votes are clustered in the top right section, but zooming in shows that lots of 0 vote games are also being estimated with the same lower dimensional representation. Lets see if adding a third PC makes it any better.

```{r, warning=F, message=F, echo=F}
plotly::plot_ly(pca_comb, x = ~PC1, y = ~PC2, z = ~PC3, color = ~brownlow_votes, size = 1, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', kicks, '<br>Marks:', marks,
                      '<br>Hb:', handballs, '<br>Goals:', goals,
                      '<br>HO:', hit_outs, '<br>OP:', one_percenters)) %>% 
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2'),
                     zaxis = list(title = 'PC3')))
```

Visualising PC3 has added arguably not that much to the interpretability of the data (but gives a cool looking plot nonetheless). Don't be fooled by the pink dots, they stand out quite a bit but if you zoom in, you can see that there are quite a few green dots scattered in there too. If you squint, you can probably convince me that the 1-3 votes are clustering together, but the definition between the groups is fairly small.

### Uniform Manifold Approximation and Projection (no scaling)

Let have a look at our non-linear dimensionality reduction technique, using the same data as before and visualise two components. An important note is that the observations are randomly initialised, so plots may look different from run to run. [3](https://umap-learn.readthedocs.io/en/latest/reproducibility.html){target='blank'}

```{r, warning=F, message=F, echo=F}
library(umap)

umap_2018 <- umap(afltables_18_data, n_components = 2, init = 'random')

umap_raw <- as_tibble(umap_2018$layout, .name_repair = 'minimal')
names(umap_raw) <- c("V1","V2")

umap_comb <- cbind(afltables_18_ind, afltables_18_data, umap_raw)

plotly::plot_ly(umap_comb, x = ~V1, y = ~V2, color = ~brownlow_votes, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', kicks, '<br>Marks:', marks,
                      '<br>Hb:', handballs, '<br>Goals:', goals,
                      '<br>HO:', hit_outs, '<br>OP', one_percenters)) %>%
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'dim1'),
                     yaxis = list(title = 'dim2')))

```

Wow, that is much better! We can clearly see some definition in the votes, as they tend to cluster towards the edge of the main group. But zooming in shows that a lot of 0 vote game interspersed in there. Interestingly, there is a clear structure made up purely of ruckmen.

Lets take a look at 3 components.

```{r, warning=F, message=F, echo=F}
umap_2018_3 <- umap(afltables_18_data, n_components = 3, init = 'random')

umap_raw_3 <- as_tibble(umap_2018_3$layout, .name_repair = 'minimal')
names(umap_raw_3) <- c("V1","V2","V3")

umap_comb_3 <- cbind(afltables_18_ind, afltables_18_data, umap_raw_3)

plotly::plot_ly(umap_comb_3, x = ~V1, y = ~V2, z = ~V3, color = ~brownlow_votes, size = 1, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', kicks, '<br>Marks:', marks,
                      '<br>Hb:', handballs, '<br>Goals:', goals,
                      '<br>HO:', hit_outs, '<br>OP', one_percenters)) %>%
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'dim1'),
                     yaxis = list(title = 'dim2'),
                     zaxis = list(title = 'dim3')))

```

We can see that vote worthy games tend to clump together, and gradually filter in with the no vote games. There also seems to be a small cluster of vote games apart from the main group, representing high hit out games (mainly ruckmen) and another cluster of high goal kickers.

# The second attempt (this time with scaling!)

One important thing to note is that the initial attempts treated all the players equally, regardless of name, playing condition, home advantage: purely based on performance. For the next attempts I'll be scaling the statistics by game, which will remove the groupl level game bias. A player that has the most touches in a wet game at 25 will no longer be treated the same as a dry 35 disposal game, but scaled relative to others they played against.

Each game will grouped and scaled, where each stat will have its mean adjusted to 0 and the variance to 1. When hovering over the points, keep in mind the following definitions:

- stat = 0: an average amount for that game
- stat > 0: higher than average
- stat < 0: lower than average

### Principal component analysis

```{r, warning=F, message=F, echo=F}
afltables_18_scaled <- afltables_18 %>% 
  group_by(round, home_team, away_team) %>% 
  mutate_at(c('kicks', 'marks', 'handballs', 'goals', 'behinds', 'hit_outs', 
              'tackles', 'rebounds', 'inside_50_s', 'clearances', 'clangers', 
              'frees_for', 'frees_against', 'contested_possessions', 
              'uncontested_possessions', 'contested_marks', 'marks_inside_50', 
              'one_percenters', 'bounces', 'goal_assists', 'time_on_ground'), 
            ~(scale(.) %>% as.vector)) %>% ungroup()

afltables_18_scaled_ind <- afltables_18_scaled %>% 
  select(id, first_name, surname, brownlow_votes)

afltables_18_scaled_data <- afltables_18_scaled %>% 
  select(kicks, marks, handballs, goals, behinds, hit_outs, tackles, rebounds, inside_50_s, clearances, clangers, frees_for, frees_against, contested_possessions, uncontested_possessions, contested_marks, marks_inside_50, one_percenters, bounces, goal_assists, time_on_ground)

pca_2018_scaled <- prcomp(afltables_18_scaled_data, scale = F, center = F)

pca_raw_scaled <- as_tibble(pca_2018_scaled$x)

pca_comb_scaled <- cbind(afltables_18_scaled_ind, afltables_18_scaled_data, pca_raw_scaled)

plotly::plot_ly(pca_comb_scaled, x = ~PC1, y = ~PC2, z = ~PC3, color = ~brownlow_votes, size = 1, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', round(kicks,3), '<br>Marks:', round(marks,3),
                      '<br>Hb:', round(handballs,3), '<br>Goals:', round(goals,3),
                      '<br>HO:', round(hit_outs,3), '<br>OP', round(one_percenters,3))) %>% 
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'PC1'),
                     yaxis = list(title = 'PC2'),
                     zaxis = list(title = 'PC3')))
```

Not bad. 3, 2 and 1 votes are clustered together towards one side. Using the selective highlighting tool, we can see that there are intersections between 0 vote games with 3 vote games. When comparing this to the umap method, we don't get a clear distinction between ruckmen and ball winners. 

### Uniform Manifold Approximation and Projection

Next up is umap with game scaled data, lets see how it fares.

```{r warning=F, message=F, echo=F}
umap_2018_scaled <- umap(afltables_18_scaled_data, n_components = 3, init = 'random')

umap_raw_scaled <- as_tibble(umap_2018_scaled$layout, .name_repair = 'minimal')
names(umap_raw_scaled) <- c("V1","V2","V3")

umap_comb_scaled <- cbind(afltables_18_scaled_ind, afltables_18_scaled_data, umap_raw_scaled)

plotly::plot_ly(umap_comb_scaled, x = ~V1, y = ~V2, z = ~V3, color = ~brownlow_votes, size = 1, hoverinfo = 'text',
        text = ~paste(first_name, surname, '<br>Kicks:', round(kicks,3), '<br>Marks:', round(marks,3),
                      '<br>Hb:', round(handballs,3), '<br>Goals:', round(goals,3),
                      '<br>HO:', round(hit_outs,3), '<br>OP', round(one_percenters,3))) %>%
  plotly::add_markers() %>% 
  plotly::layout(scene = list(xaxis = list(title = 'dim1'),
                     yaxis = list(title = 'dim2'),
                     zaxis = list(title = 'dim3')))
```

Here we can see much better definition between the types of vote worthy games:

- Kick and Marks >1
- Goals >4
- Hitouts >4

The use of a non-linear method like umap greatly helps in our understanding of the types of structures that appear in large non-linear data sources

Removing 0 vote games, we can see there is an overlap between these voted games, and presents an interesting question. Given the current data and methods there is no fundamental difference between these games. Given how similar these games are to each other, is there truly a 3 vote game? If not, how certain can we be of models that predict a 3 vote game?

# Future Work

Next post on this topic will be the generation of predictions using the generated lower dimensional embeddings, and compare their effectiveness against the PCA, and against more components. Given this exploration was on 2018 data, I'll generate predictions for 2019 and compare the results.

Grouping and scaling by game probably isn't the most effective way to normalize the data, and future investigations might uncover better ways to scale the data.

Feature selection techniques can be employed to filter out data (maybe bounces) that are not predictive of brownlow votes. A simple method would be Weight of Effect

afltables.com is not an exhaustive source of AFL statistics, and until Champion Data gets its act together and has a change of heart to release data to the amateur AFL analytics community, this is probably the best we can get. Additional work has been done by [\@Fryzigg](https://twitter.com/Fryzigg){target="blank"} to add higher level data and would be a worthwhile investigation.

I have been running umap with the default parameter settings, and tweaking these may produce better results. These include: [4](https://umap-learn.readthedocs.io/en/latest/parameters.html){target='blank'}

- Number of neighbours: local vs global data
- Minimum distance: How close the points are together
- Number of components: Investigated, maybe 10 dimensions are needed to generate predictions from
- Metric: How is distance computed (euclidean, manhattan)



# Conclusion

I believe that there are 3 main takeaways from this analysis that can improve our understanding of how brownlow votes are allocated.

- Use non-linear methods for determining brownlow votes
- There is (most likely) no discernible difference between 1, 2 and 3 vote games
- If there's no discernible difference between voted games, then confidence intervals should reflect it
- Scaling data per game improves interpretability

Thanks for making it this far, you can check out the script I used to generate this analysis [here](https://github.com/liam-crow/stats-blog/tree/master/content/post){target="blank"}. You can ask me questions about analysis at my twitter [\@crow_data_sci](https://twitter.com/crow_data_sci){target="blank"}.

Also, make sure to check out my previous post, [Intro to AFL Stats in R](https://www.crowdatascience.com/2020/07/16/introduction-afl-analytics-data-r/){target='blank'}.
